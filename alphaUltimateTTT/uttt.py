# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Game/ultimatettt.ipynb.

# %% auto 0
__all__ = ['SIZE', 'NEXT_SYMBOL_INDEX', 'CONSTRAINT_INDEX', 'RESULT_INDEX', 'X_STATE_VALUE', 'O_STATE_VALUE', 'DRAW_STATE_VALUE',
           'UNCONSTRAINED_STATE_VALUE', 'Action', 'UltimateTicTacToe', 'utttError']

# %% ../nbs/Game/ultimatettt.ipynb 4
#0-80 squares, 81-89 result of each subgame, 90 next symbol, 91 subgame constraint, 92 result of uttt
SIZE = 93 
NEXT_SYMBOL_INDEX = 90
CONSTRAINT_INDEX = 91
RESULT_INDEX = 92

X_STATE_VALUE = 1
O_STATE_VALUE = 2
DRAW_STATE_VALUE = 3
UNCONSTRAINED_STATE_VALUE = 9

# %% ../nbs/Game/ultimatettt.ipynb 5
class Action:
    def __init__(self,
                symbol: int, # X_STATE_VALUE = 1 or O_STATE_VALUE = 2
                index: int): # int from 0 to 80
        '''An action contains the symbol (represented as an int) and the index (int from 0 to 80) where the symbol will be placed.'''
        self.symbol = symbol  # X_STATE_VALUE or O_STATE_VALUE
        self.index = index  # int from 0 to 80

    def is_symbol_X(self) -> bool:
        return self.symbol == X_STATE_VALUE

    def is_symbol_O(self) -> bool:
        return self.symbol == O_STATE_VALUE

    def __str__(self):
        output = '{cls}(symbol={symbol}, index={index})'
        output = output.format(
            cls=self.__class__.__name__,
            symbol={X_STATE_VALUE: 'X', O_STATE_VALUE: 'O'}[self.symbol],
            index=self.index,
        )
        return output

# %% ../nbs/Game/ultimatettt.ipynb 6
class UltimateTicTacToe:
    def __init__(self,
                state:bytearray = None): #If no state is given, it generates a new one. 
        '''The state is a bytearray of 93 elements. 
        The first 81 elements are the state of each square, 0 for empty, 1 for X and -1 for O. \n
        The next 9 elements are the result of each subgame, 0 for draw, 1 for X and -1 for O.\n 
        The next element is the next symbol to play, 1 for X and 2 for O.\n 
        The next element is the index of the subgame that is constrained, 9 for no subgame constrained. \n
        The last element is the result of the UTTT, 0 while being played, 3 for draw, 2 for O and 1 for X.'''
        if state:
            self.state = state
        else:
            self.state = bytearray(SIZE) #generates the array
            self.state[NEXT_SYMBOL_INDEX] = X_STATE_VALUE #X always starts the game
            self.state[CONSTRAINT_INDEX] = UNCONSTRAINED_STATE_VALUE #no subgame is constrained at the beginning
   

    def is_game_over(self) -> bool:
        '''Returns True if the game is over, False otherwise.'''
        return bool(self.state[RESULT_INDEX])
    
    def is_next_symbol_X(self) -> bool:
        '''Returns True if the next symbol to play is X, False otherwise.'''
        return self.state[NEXT_SYMBOL_INDEX] == X_STATE_VALUE
    
    def is_next_symbol_O(self) -> bool:
        '''Returns True if the next symbol to play is O, False otherwise.'''
        return self.state[NEXT_SYMBOL_INDEX] == O_STATE_VALUE
    
    def is_constrained(self) -> bool:
        '''Returns True if a subgame is constrained, False otherwise.'''
        return self.state[CONSTRAINT_INDEX] != UNCONSTRAINED_STATE_VALUE
    
    
    def _verify_action(self, action: Action):
        illegal_action = f"Illegal action {action} - "
        if self.is_next_symbol_X() and not action.is_symbol_X():
            raise utttError(illegal_action + "next move belongs to X")
        if self.is_next_symbol_O() and not action.is_symbol_O():
            raise utttError(illegal_action + "next move belongs to O")
        if not (0 <= action.index < 81):
            raise utttError(illegal_action + "index outside the valid range")
        if self.is_constrained() and self.constraint != action.index // 9:
            raise utttError(illegal_action + f"violated constraint={self.constraint}")
        if self.state[81 + action.index // 9]:
            raise utttError(illegal_action + "index from terminated subgame")
        if self.state[action.index]:
            raise utttError(illegal_action + "index is already taken")

    def make_move(self,
                action: Action, #Receives an action and updates the state of the game.
                verify: bool = True): #A boolean to verify if the move is valid.
        '''Makes a move in the game.'''
        if verify:
            if self.is_game_over():
                raise utttError('The game is over')
            self._verify_action(action)
            

# %% ../nbs/Game/ultimatettt.ipynb 8
class utttError(Exception):
    pass
